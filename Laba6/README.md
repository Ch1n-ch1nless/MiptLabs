<h1 align="center">Привет, я <a href="https://t.me/Chin_chinless" target="_blank">Олег</a>
<img src="https://github.com/blackcater/blackcater/raw/main/images/Hi.gif" height="32"/></h1>
<h4 align="center">Я автор лабораторной работы №6</h4>

# Тема: 
Сравнение времени работы различных деревьев поиска

# Цель:
Реализовать различные версии деревьев поиска, измерить время их работы и узнать, какая из них работает быстрее.

# Содержание:

1.  [Подготовка тестов для замеров времени](#подготовка-тестов-для-замеров-времени)
    1. [Оборудование для тестов](#оборудование-для-тестов)
    2. [Описание тестов](#описание-тестов)
2.  [Бинарное дерево поиска](#бинарное-дерево-поиска)
3.  [AVL-дерево](#avl-дерево)
4.  [Декартово дерево](#декартово-дерево)
5.  [Splay дерево](#splay-дерево)
6.  [Красно-чёрное дерево](#красно-чёрное-дерево)
7.  [SkipList](#skiplist)
8.  [Вывод](#вывод)

# Подготовка тестов для замеров времени

### Оборудование для тестов 

**Процессор**: AMD Ryzen 7 5800H 3.22 Ghz
**ОЗУ**: 16 Гб
**ОС**: Linux Ubuntu 22.04.4 LTS
**Компилятор**: cc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0

### Описание тестов

Для запуска тестов нужно ввести следующие команды:

```
git clone git@github.com:Ch1n-ch1nless/MiptLabs.git -b "Laboratory_work#6"  # скопировать ветку с гитхаба
cd MiptLabs/Laba6                                                           # перейти в папку с файлами
make test_generate                                                          # запустить генерацию тестов
```

Далее появится папка: `Tests`, в ней будут файлы, в которых записаны ключей:
10 файлов с случайными ключами с "100000.in" до "1000000.in" с шагом = 100000. И 2 файла "sorted_100000.in" и "sorted_1000000.in", в них находятся отсортированное множество ключей.

Все деревья прогоняются через тесты с файлами и замеряются время работы программы. 

# Бинарное дерево поиска

**Бинарное дерево поиска** - это структура данных, которая позволяет находить элементы из упорядоченного множества. Оно обладает следующим свойством: если $x$ — узел бинарного дерева с ключом $k$, то все узлы в левом поддереве должны иметь ключи, меньшие $k$, а в правом поддереве большие $k$.

Данное дерево не обладает ни какой балансировки, и оно при определенных данных может превратиться в "бамбук", то есть высота дерева будет $= n$.
Картинка, как выглядит бамбук:
![](Images/bamboo.png)

Рассмотрим, как быстро работает BST:

| Тип операции  | Время работы со случайным множеством ключей   | Время работы с отсортированным множеством ключей  |
|:-------------:|:---------------------------------------------:|:-------------------------------------------------:|
|   Вставка     |          $61,80$ миллисекунд                  |             $31,24$ миллисекунд                   |
|   Удаление    |         $7189,23$ миллисекунд                 |            $3329,55$ миллисекунд                  |

BST работает с отсортированным множеством ключей в 100 раз медленнее, чем со случайным множеством ключей. Это объясняется легко, так при отсортированном множестве BST превращается в бамбук, и соответственно, вставка и удаление работает не за $O(h)$, а за $O(n)$.

**Итог:** Использовать BST - не самая лучшая идея, так как очень просто замедлить в 100 раз программу.

# AVL дерево

**AVL-дерево** - это сбалансированное бинарное дерево поиска, которое сохраняет следующее свойство:
*для каждой его вершины высота её двух поддеревьев различается не более чем на 1.*

Благодаря этому свойству, AVL-дерево не превратиться в бамбук, а всегда будет иметь высоту $h = O(logN)$. Проверим, действительно ли AVL-дерево быстрее, чем BST.

| Дерево    | Время вставки $10^5$ случайных элементов  |   Время удаления $5 \cdot 10^4$ случайных элементов   |
|:---------:|:-----------------------------------------:|:-----------------------------------------------------:|
|   BST     |       $61,80$ миллисекунд                 |       $31,24$ миллисекунд                             |
|   AVL     |       $49,78$ миллисекунд                 |       $27,63$ миллисекунд                             |

Для случайного набора элементов AVL работает быстрее, чем BST, но не значительно, рассмотрим дополнительно время на отсортированном множестве ключей.

| Дерево    | Время вставки $10^5$ отсортированных элементов    | Время удаления $5 \cdot 10^4$ отсортированных элементов   |
|:---------:|:-------------------------------------------------:|:---------------------------------------------------------:|
|   BST     |       $7189,23$ миллисекунд                       |           $3329,55$ миллисекунд                           |
|   AVL     |       $32.83$ миллисекунд                         |           $13.23$ миллисекунд                             |   

Разница очень сильно заметна, так как AVL работает быстрее в $\approx 220$ раз, чем BST!

**Итог:** AVL-дерево работает в разы лучше, чем BST. Поэтому в дальнейших исследованиях рассмотрение BST бессмысленно.

# Декартово дерево

# Splay дерево

# Красно-чёрное дерево

# SkipList

# Вывод