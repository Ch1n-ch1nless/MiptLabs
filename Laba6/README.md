<h1 align="center">Привет, я <a href="https://t.me/Chin_chinless" target="_blank">Олег</a>
<img src="https://github.com/blackcater/blackcater/raw/main/images/Hi.gif" height="32"/></h1>
<h4 align="center">Я автор лабораторной работы №6</h4>

# Тема: 
Сравнение времени работы различных деревьев поиска

# Цель:
Реализовать различные версии деревьев поиска, измерить время их работы и узнать, какая из них работает быстрее.

# Содержание:

1.  [Подготовка тестов для замеров времени](#подготовка-тестов-для-замеров-времени)
    1. [Оборудование для тестов](#оборудование-для-тестов)
    2. [Описание тестов](#описание-тестов)
2.  [Бинарное дерево поиска](#бинарное-дерево-поиска)
3.  [AVL дерево](#avl-дерево)
4.  [Декартово дерево](#декартово-дерево)
5.  [Splay дерево](#splay-дерево)
6.  [Красно-чёрное дерево](#красно-чёрное-дерево)
7.  [SkipList](#skiplist)
8.  [Вывод](#вывод)

# Подготовка тестов для замеров времени

### Оборудование для тестов 

### Описание тестов

# Бинарное дерево поиска

**Бинарное дерево поиска** - это структура данных, которая позволяет находить элементы из упорядоченного множества. Оно обладает следующим свойством: если $x$ — узел бинарного дерева с ключом $k$, то все узлы в левом поддереве должны иметь ключи, меньшие $k$, а в правом поддереве большие $k$.

Данное дерево не обладает ни какой балансировки, и оно при определенных данных может превратиться в "бамбук", то есть высота дерева будет $= n$.
Картинка, как выглядит бамбук:
![](Images/bamboo.png)

Рассмотрим, как быстро работает BST:

| Тип операции  | Время работы со случайным множеством ключей   | Время работы с отсортированным множеством ключей  |
|:-------------:|:---------------------------------------------:|:-------------------------------------------------:|
|   Вставка     |          $61,80$ миллисекунд                  |             $31,24$ миллисекунд                   |
|   Удаление    |          $7189,23$ миллисекунд                |           $3329,55$ миллисекунд                   |

BST работает с отсортированным множеством ключей в 100 раз медленнее, чем со случайным множеством ключей. Это объясняется легко, так при отсортированном множестве BST превращается в бамбук, и соответственно, вставка и удаление работает не за $O(h)$, а за $O(n)$.

**Итог:** Использовать BST - не самая лучшая идея, так как очень просто замедлить в 100 раз программу.

# AVL дерево

# Декартово дерево

# Splay дерево

# Красно-чёрное дерево

# SkipList

# Вывод